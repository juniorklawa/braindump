{"index":{"title":"Brain Overflow","links":["posts/The-Never-Ending-Battle-Against-Software-Complexity","projects/Interview-Bro","projects/Codict","projects/RevisApp---Enem-e-Vestibular","projects/RevisApp-Concursos","projects/BrainOverflow","other/Inactive-Projects"],"tags":[],"content":"Hi, I’m Everaldo and this is my brain dump.\nCheck my:\nLinkedIn • Twitter • Github\nRecent Posts\n\nThe Never Ending Battle Against Software Complexity\n\nProjects\n\nInterview Bro\nCodict\nRevisApp - Enem e Vestibular\nRevisApp Concursos\nThis Blog\n\nif you want to see a list of my failed inactive projects, click here"},"other/Inactive-Projects":{"title":"Inactive Projects","links":["projects/Strackify","Localdemy","dumonbot","doggo-bot","react-native-auto-size-text","Trashfy","Nicks-for-CS:GO","Revisa-Detran","Click-to-Corrupt","Cube-Life","My-Awesome-Idea","Holy-Check","Revisa-Quiz","Gerador-de-Horóscopo","DADGAD-Chords","MarkSync"],"tags":[],"content":"\nStrackify\nLocaldemy\ndumonbot\ndoggo bot\nreact-native-auto-size-text\nTrashfy\nNicks for CS:GO\nRevisa Detran\nClick to Corrupt\nCube Life\nMy Awesome Idea\nHoly Check\nRevisa Quiz\nGerador de Horóscopo\nDADGAD Chords\nMarkSync\n"},"posts/The-Never-Ending-Battle-Against-Software-Complexity":{"title":"The Never Ending Battle Against Software Complexity","links":[],"tags":[],"content":"What is Complexity?\nRecently, I finished reading “A Philosophy of Software Design” and in the second chapter, it explores the topic of Software Complexity. \nThe book “A Philosophy of Software Design” defines complexity practically:\n\n“Complexity is anything related to the structure of a software system that makes it hard to understand and modify.”\n\nIn other words, complexity can take many forms, and doesnt necessary has anything to do with performance, your code can be performant and still be complex\nI’d like to share some key definitions and insights from the book in this article. But first, let’s imagine a common situation that probably you’ve already been to…\n\nA Short Horror Story\nLet’s dive into a horror story many of you have probably experienced or will experience.\n\n\nIt started with a simple CRUD task management app. The code was clean, modular, and easy to maintain. The development team was happy, and the system worked perfectly for initial clients.\n\n\nProblems began when the sales team sold the system to a large company, claiming it had calendar integration, email notifications, and an amazing report generator. With the sale finalized, these features had to be implemented quickly.\n\n\nCalendar Integration: The team had to integrate with Google Calendar and Outlook. Different developers implemented the solutions, resulting in inconsistent approaches.\n\n\nEmail Notifications: Email notifications were added next. One developer used a specific library, while another created a custom solution. The mixed approaches made the code confusing.\n\n\nReport Generator: For the report generator, developers used various technologies: PDFs, Excel exports, and interactive dashboards. The lack of a unified approach made maintenance a nightmare.\n\n\nGrowing Complexity: Each feature was developed in isolation and quickly, leading to dependencies between features. Developers started creating “quick fixes” to make everything work, increasing the system’s complexity and coupling.\n\n\nSoftware development doesn’t happen in a vacuum; various internal and external factors influence it. We’ve all been, or will be, in a situation like this.\n\nThe Beginning of the End\nThen the problems began:\n\nChanges in one part of the system affected other parts unexpectedly.\nSmall changes required modifications in many other files, making estimations difficult.\nMonth after month, the code became harder to understand, often fixed through trial and error.\nProductivity declined, and everyone dreaded maintenance tasks.\nThe inevitable call for “We need to refactor.”\nCertain tasks could only be handled by specific developers (classic)\nOver time, the once beautifully written and well-documented software became a train wreck.\n\nNaming the Symptoms\nIt’s clear we now have a complex system.\nNow let’s “dissect” this complexity to make it easier to identify and mitigate it.\nWell, “mitigate” means:\n\n“To make less severe, serious, or painful; to alleviate.”\n\nI believe complexity is often inherent in code. Some things are complex by nature. Your role as a developer isn’t just to create code that the computer can execute efficiently but also to create code that future developers (including your future self) can work with.\n\n“Controlling complexity is the essence of computer programming.”\n— Brian Kernighan\n\nThe author of the mentioned book states that complexity typically manifests in three ways, which we will explore here.\nChange Amplification\n\nChange amplification occurs when a seemingly simple change requires modifications in many different places.\n\nFor example, if the Product Owner requests a “priority” or “completion date” field and your entities are tightly coupled, how many changes would you need to make?\nCognitive Load\n\nCognitive load refers to the amount of knowledge and time a developer needs to complete a task.\n\nSo imagine this scenario: A new developer joined the team, he was assigned to fix a bug in the report generator. To complete this task, the dev needed to:\n\nUnderstand the different calendar integrations (Google and Outlook).\nGrasp the distinct approaches to email notifications.\nNavigate through the fragmented code of the report generator, dealing with PDFs, Excel, and dashboards.\nIntegrate these diverse technologies and styles to find and fix the bug.\n\nIt’s the classic “impossible to estimate” scenario, where the task could take one point or eight—better roll a D20 and respond accordingly.\nUnknown Unknowns\n\nUnknown unknowns are when you don’t know what you don’t know.\n\nThis is the worst manifestation of complexity because you might alter things you shouldn’t, causing everything to break.\nExample: A developer modified the email-sending code to add a new notification, unaware that it would affect the report generator, which depended on that function. This caused significant issues for clients, exemplifying the worst form of emergent complexity.\nCauses of Complexity\nHaving seen the horror story and the three main symptoms, let’s look at what causes complexity.\n1. Dependencies\nDependencies are essential in software and cannot be completely eliminated. They allow different parts of the system to interact and function together. However, dependencies, when not managed properly, can significantly increase complexity.\nDefinition:\n\nA dependency exists when code cannot be understood or modified in isolation, requiring consideration or modification of related code.\n\nTypes of Dependencies:\n\nDirect Dependencies: When a module or class relies directly on another. For example, if Class A calls a method from Class B, Class A is directly dependent on Class B.\nTransitive Dependencies: These occur indirectly. For instance, if Class A depends on Class B, and Class B depends on Class C, then Class A has a transitive dependency on Class C.\nCyclic Dependencies: These are the worst form of dependencies where a group of modules are interdependent in a circular manner. This can lead to severe maintenance and scalability issues.\n\n2. Obscurity\nObscurity occurs when important information is not obvious. This can make the codebase hard to understand, leading to increased cognitive load and the risk of unknown unknowns.\nDefinition:\n\nObscurity occurs when important information is not obvious.\n\nExamples of Obscurity:\n\nPoorly Named Variables and Functions: Names that do not convey the purpose or usage can lead to confusion. For instance, variables named x or temp without context.\nHidden Side Effects: Functions that modify state or perform actions that are not apparent from their signature can introduce obscurity. For example, a method named calculateTotal that also updates the database.\nGlobal State: Overuse of global variables can lead to hidden dependencies and side effects, making the code difficult to understand and predict.\nDeep Inheritance Hierarchies: Inheritance can obscure the actual behavior of classes, especially when behavior is spread across multiple levels of the hierarchy.\n\nRemember: Complexity is Incremental\n\nComplexity is rarely caused by a single “error” or bad decision.\nComplexity builds up “slowly” through bad decisions and dependencies over time.\n\nBecause it is incremental, it’s easy to think, “just this once, it won’t matter.” But when accumulated, fixing one or two dependencies alone won’t make much difference.\n\n“Everything is a tradeoff in software engineering.”\n— I don’t remember the author\n\nConclusion\nI could  write a lot of rules, stratategies and frameworks and  that you priobably already saw in the intenert on hjow to avoid complexity: SOLID, Design Patterns, Yagni, KISS etc etc\nHowever, you can unify them all into one guiding principle (as mentioned in “The Pragmatic Programmer.“):  “Is what I am implementing easy to change?” If the answer is no, then you are probably increasing complexity.\nEnsuring that your code is easy to change not only simplifies maintenance but also reduces the cognitive load on developers, making the system more adaptable and less error-prone over time."},"projects/BrainOverflow":{"title":"BrainOverflow","links":[],"tags":[],"content":""},"projects/Codict":{"title":"Codict","links":[],"tags":[],"content":""},"projects/Interview-Bro":{"title":"Interview Bro","links":[],"tags":[],"content":""},"projects/Marksync":{"title":"Marksync","links":[],"tags":[],"content":""},"projects/RevisApp---Enem-e-Vestibular":{"title":"RevisApp - Enem e Vestibular","links":[],"tags":[],"content":""},"projects/RevisApp-Concursos":{"title":"RevisApp Concursos","links":[],"tags":[],"content":""},"projects/Strackify":{"title":"Strackify","links":[],"tags":[],"content":""}}